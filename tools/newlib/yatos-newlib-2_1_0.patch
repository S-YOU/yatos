diff --git a/config.sub b/config.sub
index 8b612ab..afe8f86 100755
--- a/config.sub
+++ b/config.sub
@@ -2,7 +2,7 @@
 # Configuration validation subroutine script.
 #   Copyright 1992-2013 Free Software Foundation, Inc.
 
-timestamp='2013-04-24'
+timestamp='2016-05-08'
 
 # This file is free software; you can redistribute it and/or modify it
 # under the terms of the GNU General Public License as published by
@@ -1355,6 +1355,7 @@ case $os in
 	      | -sym* | -kopensolaris* | -plan9* \
 	      | -amigaos* | -amigados* | -msdos* | -newsos* | -unicos* | -aof* \
 	      | -aos* | -aros* \
+	      | -yatos* \
 	      | -nindy* | -vxsim* | -vxworks* | -ebmon* | -hms* | -mvs* \
 	      | -clix* | -riscos* | -uniplus* | -iris* | -rtu* | -xenix* \
 	      | -hiux* | -386bsd* | -knetbsd* | -mirbsd* | -netbsd* \
diff --git a/newlib/configure.host b/newlib/configure.host
index 58faa95..2d534b6 100644
--- a/newlib/configure.host
+++ b/newlib/configure.host
@@ -539,6 +539,9 @@ case "${host}" in
   z8k-*-coff)
 	sys_dir=z8ksim
 	;;
+  x86_64-*-yatos*)
+	sys_dir=yatos
+	;;
 esac
 
 # Host specific flag settings -- usually for features that are not
diff --git a/newlib/libc/sys/configure.in b/newlib/libc/sys/configure.in
index c355659..821d5c9 100644
--- a/newlib/libc/sys/configure.in
+++ b/newlib/libc/sys/configure.in
@@ -47,6 +47,7 @@ if test -n "${sys_dir}"; then
 	tic80) AC_CONFIG_SUBDIRS(tic80) ;;
 	w65) AC_CONFIG_SUBDIRS(w65) ;;
 	z8ksim) AC_CONFIG_SUBDIRS(z8ksim) ;;
+	yatos) AC_CONFIG_SUBDIRS(yatos) ;;
   esac;
 fi
 
diff --git a/newlib/libc/sys/yatos/Makefile.am b/newlib/libc/sys/yatos/Makefile.am
new file mode 100644
index 0000000..4664dcb
--- /dev/null
+++ b/newlib/libc/sys/yatos/Makefile.am
@@ -0,0 +1,15 @@
+AUTOMAKE_OPTIONS = cygnus
+INCLUDES = $(NEWLIB_CFLAGS) $(CROSS_CFLAGS) $(TARGET_CFLAGS)
+AM_CCASFLAGS = $(INCLUDES)
+
+noinst_LIBRARIES = lib.a
+
+lib_a_SOURCES = syscalls.c
+lib_a_CCASFLAGS = $(AM_CCASFLAGS)
+lib_a_CFLAGS = $(AM_CFLAGS)
+
+all: crt0.o
+
+ACLOCAL_AMFLAGS = -I ../../.. -I ../../../..
+CONFIG_STATUS_DEPENDENCIES = $(newlib_basedir)/configure.host
+
diff --git a/newlib/libc/sys/yatos/configure.in b/newlib/libc/sys/yatos/configure.in
new file mode 100644
index 0000000..9e15348
--- /dev/null
+++ b/newlib/libc/sys/yatos/configure.in
@@ -0,0 +1,7 @@
+AC_PREREQ(2.59)
+AC_INIT([newlib], [NEWLIB_VERSION])
+AC_CONFIG_SRCDIR([crt0.c])
+AC_CONFIG_AUX_DIR(../../../..)
+NEWLIB_CONFIGURE(../../..)
+AC_CONFIG_FILES([Makefile])
+AC_OUTPUT
diff --git a/newlib/libc/sys/yatos/crt0.c b/newlib/libc/sys/yatos/crt0.c
new file mode 100644
index 0000000..5c9be6a
--- /dev/null
+++ b/newlib/libc/sys/yatos/crt0.c
@@ -0,0 +1,39 @@
+/* -*- mode: C; coding:utf-8 -*- */
+/**********************************************************************/
+/*  Yet Another Teachable Operating System                            */
+/*  Copyright 2016 Takeharu KATO                                      */
+/*                                                                    */
+/*  Userlland start routine                                           */
+/*                                                                    */
+/**********************************************************************/
+
+#include <stdint.h>
+#include <stddef.h>
+#include <stdbool.h>
+
+typedef uint64_t syscall_arg_type;  /*< システムコール引数の型  */
+typedef int64_t  syscall_res_type;  /*< システムコール結果の型  */
+
+extern int main(int _argc, char *_argv[]);
+extern void set_errno(syscall_res_type _res);
+extern void _clear_bss(void);
+extern void yatos_thread_exit(int rc);
+extern void _yatos_register_common_event_handler(void);
+
+char **environ;
+
+void
+_start(int argc, char *argv[], char **envp) {
+	int rc;
+
+	_clear_bss();
+
+	environ = envp;
+	__yatos_user_event_handler_init();
+	_yatos_register_common_event_handler();
+
+	rc = main(argc, argv);
+
+	yatos_thread_exit(rc);
+}
+
diff --git a/newlib/libc/sys/yatos/syscalls.c b/newlib/libc/sys/yatos/syscalls.c
new file mode 100644
index 0000000..4ea82ba
--- /dev/null
+++ b/newlib/libc/sys/yatos/syscalls.c
@@ -0,0 +1,134 @@
+#include <sys/stat.h>
+#include <sys/types.h>
+#include <sys/fcntl.h>
+#include <sys/times.h>
+#include <sys/errno.h>
+#include <sys/time.h>
+#include <stdio.h>
+#include <stdint.h>
+
+typedef int64_t  syscall_res_type;  /*< システムコール結果の型  */
+extern void      set_errno(syscall_res_type _res);
+extern int       yatos_printf(const char *fmt,...);
+extern void      yatos_thread_exit(int rc);
+extern uint64_t  yatos_thread_getid(void);
+extern int       yatos_proc_send_proc_event(uint64_t _dest, int  _id, void *_data);
+extern void     *yatos_vm_sbrk(intptr_t increment);
+extern int       yatos_thread_wait(uint64_t _wait_tid, uint32_t _wflags, 
+    uint64_t *_exit_tidp, uint64_t *_rcp);
+
+void
+_exit(void){
+
+	yatos_thread_exit(0);
+}
+int
+close(int file){
+
+	return -1;
+}
+
+int 
+execve(char *name, char **argv, char **env) {
+
+		set_errno( -ENOMEM );
+		return -1;
+}
+int
+fork(void){
+
+	set_errno( -EAGAIN );
+	return -1;
+}
+int
+fstat(int file, struct stat *st){
+
+	st->st_mode = S_IFCHR;
+	return 0;
+}
+int 
+getpid(void){
+	
+	return yatos_thread_getid();
+}
+int
+isatty(int file) {
+	
+	return 1;
+}
+int
+kill(int pid, int sig) {
+
+	return yatos_proc_send_event(pid, sig, NULL);
+}
+int
+link(char *old, char *new){
+
+	set_errno( -EMLINK );
+	return -1;
+}
+int
+lseek(int file, int ptr, int dir) {
+
+	return 0;
+}
+int 
+open(const char *name, int flags, ...) {
+
+	return -1;
+}
+int
+read(int file, char *ptr, int len) {
+
+	return 0;
+}
+caddr_t 
+sbrk(int incr){
+
+	return (caddr_t)yatos_vm_sbrk( (intptr_t)incr );
+}
+int
+stat(const char *file, struct stat *st){
+
+	st->st_mode = S_IFCHR;
+	return 0;
+}
+clock_t 
+times(struct tms *buf) {
+	return -1;
+}
+int
+unlink(char *name) {
+
+	return -1;
+}
+int
+wait(int *status) {
+	uint64_t exit_tid;
+	uint64_t     chrc;
+	int            rc;
+
+	rc = yatos_thread_wait(0, 0, &exit_tid, &chrc);
+	if ( rc == 0 )
+		*status = chrc;
+	return 	rc;
+}
+int
+write(int file, char *ptr, int len) {
+	char buff[256];
+	int  wlen;
+	
+	wlen = len;
+	if ( len > 256)
+		wlen = 256;
+	memcpy(buff, ptr, wlen);
+	buff[255]='\0';
+
+	return yatos_printf("%s", buff);	
+}
+int
+gettimeofday(struct timeval *p, void *z) {
+
+	set_errno( -ENOSYS );
+	return -1;
+}
